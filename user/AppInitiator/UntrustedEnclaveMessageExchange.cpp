#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include "sgx_eid.h"
#include "error_codes.h"
#include "datatypes.h"
#include "sgx_urts.h"
#include "UntrustedEnclaveMessageExchange.h"
#include "sgx_dh.h"
#include "fifo_def.h"
#include <map>
#include "sgx_dcap_ql_wrapper.h"
#include "sgx_quote_3.h"
#include "sgx_dcap_quoteverify.h"


/* Function Description: This is OCALL interface for initiator enclave to get ECDH message 1 and session id from responder enclave
 * Parameter Description:
 *      [input, output] dh_msg1: pointer to ecdh msg1 buffer, this buffer is allocated in initiator enclave and filled by responder enclave
 *      [output] session_id: pointer to session id which is allocated by responder enclave
 * */
extern "C" ATTESTATION_STATUS session_request_ocall(sgx_dh_dcap_msg1_t* dh_msg1, uint32_t* session_id, sgx_enclave_id_t wasm_vm_enclave_id){
	FIFO_MSG msg1_request;
	FIFO_MSG *msg1_response;
	SESSION_MSG1_RESP * msg1_respbody = NULL;
	size_t  msg1_resp_size;
	
	// wasm_vm_enclave_id is not used in this implementation, just for compatibility
	(void)wasm_vm_enclave_id;

	msg1_request.header.type = FIFO_DH_REQ_MSG1;
	msg1_request.header.size = 0;

	if ((client_send_receive(&msg1_request, sizeof(FIFO_MSG), &msg1_response, &msg1_resp_size) != 0)
		|| (msg1_response == NULL))
	{
		printf("fail to send and receive message.\n");
		return INVALID_SESSION;
	}

	msg1_respbody = (SESSION_MSG1_RESP *)msg1_response->msgbuf;

	// Copy DCAP msg1 directly (now using DCAP format in SESSION_MSG1_RESP)
	memcpy(dh_msg1, &msg1_respbody->dh_msg1, sizeof(sgx_dh_dcap_msg1_t));
	*session_id = msg1_respbody->sessionid;
        free(msg1_response);

	return (ATTESTATION_STATUS)0;

}

/* Function Description: This is OCALL interface for initiator enclave to send ECDH message 2 to responder enclave, and receive ECDH message 3 from responder enclave
 * Parameter Description:
 *      [input] dh_msg2: this is pointer to ECDH message 2 generated by initiator enclave
 *      [input, output]dh_msg3: this is pointer to ECDH message 3, this buffer is allocated in initiator enclave and filled by responder enclave
 *      [input] session_id: this is session id allocated by responder enclave
 * */
ATTESTATION_STATUS exchange_report_ocall(sgx_dh_dcap_msg2_t *dh_msg2, sgx_dh_dcap_msg3_t *dh_msg3, uint32_t session_id, sgx_enclave_id_t wasm_vm_enclave_id)
{
	FIFO_MSG * msg2 = NULL, * msg3 = NULL;
	FIFO_MSG_HEADER * msg2_header = NULL;
	SESSION_MSG2 *msg2_body = NULL;
	SESSION_MSG3 *msg3_body = NULL;
	size_t msg2size, msg3size;
	
	// wasm_vm_enclave_id is not used in this implementation, just for compatibility
	(void)wasm_vm_enclave_id;

	msg2size = sizeof(FIFO_MSG_HEADER) + sizeof(SESSION_MSG2);
	msg2 = (FIFO_MSG *)malloc(msg2size);
	if (!msg2)
	{
		return ERROR_OUT_OF_MEMORY;
	}
	memset(msg2, 0, msg2size);

	msg2_header = (FIFO_MSG_HEADER *)msg2;
	msg2_header->type = FIFO_DH_MSG2;
	msg2_header->size = sizeof(SESSION_MSG2);

	msg2_body = (SESSION_MSG2 *)msg2->msgbuf;
	// Copy DCAP msg2 directly (now using DCAP format in SESSION_MSG2)
	memcpy(&msg2_body->dh_msg2, dh_msg2, sizeof(sgx_dh_dcap_msg2_t));
	msg2_body->sessionid = session_id;

	if (client_send_receive(msg2, msg2size, &msg3, &msg3size) != 0)
	{
		free(msg2);
		printf("failed to send and receive message.\n");
		return INVALID_SESSION;
	}

	msg3_body = (SESSION_MSG3 *)msg3->msgbuf;
	// Copy DCAP msg3 directly (now using DCAP format in SESSION_MSG3)
	memcpy(dh_msg3, &msg3_body->dh_msg3, sizeof(sgx_dh_dcap_msg3_t));

	free(msg3);
	free(msg2);

	return (ATTESTATION_STATUS)0;
}

/* Function Description: This is OCALL interface for initiator enclave to send request message(encrypted) to responder enclave, and receive response message from responder enclave
 * Parameter Description:
 *      [input] session_id: this is session id allocated by responder enclave
 *      [input] req_message: this is pointer to request message
 *      [input] req_message_size: this is request message size
 *      [input] max_payload_size: this is maximum payload size in response message
 *      [input, output] this is pointer to response message, the buffer is allocated by initiator enclave and filled by responder enclave
 *      [input] response message size
 * */
ATTESTATION_STATUS send_request_ocall(uint32_t session_id, 
secure_message_t* req_message, 
size_t req_message_size, 
size_t max_payload_size, 
secure_message_t* resp_message, 
size_t resp_message_size, 
sgx_enclave_id_t wasm_vm_enclave_id)
{
	FIFO_MSG *msgreq = NULL, *msgresp= NULL;
	FIFO_MSGBODY_REQ * msgbody;

	size_t reqsize, respsize;
	
	// wasm_vm_enclave_id is not used in this implementation, just for compatibility
	(void)wasm_vm_enclave_id;

	reqsize = sizeof(FIFO_MSG_HEADER) + sizeof(FIFO_MSGBODY_REQ) + req_message_size;

	msgreq = (FIFO_MSG *)malloc(reqsize);
	if (!msgreq)
	{
		return ERROR_OUT_OF_MEMORY;
	}
	memset(msgreq, 0, reqsize);

	msgreq->header.type = FIFO_DH_MSG_REQ;
	msgreq->header.size = sizeof(FIFO_MSGBODY_REQ) + req_message_size;

	msgbody = (FIFO_MSGBODY_REQ *)msgreq->msgbuf;
	msgbody->max_payload_size = max_payload_size;
	msgbody->size = req_message_size;
	msgbody->session_id = session_id;

	memcpy(msgbody->buf, req_message, req_message_size);

	if (client_send_receive(msgreq, reqsize, &msgresp, &respsize) != 0)
	{
		free(msgreq);
		printf("fail to send and receive message.\n");
		return INVALID_SESSION;
	}

	memcpy(resp_message, msgresp->msgbuf, msgresp->header.size < resp_message_size ? msgresp->header.size : resp_message_size);
	free(msgresp);
	free(msgreq);

	return (ATTESTATION_STATUS)0;
}


ATTESTATION_STATUS send_user_request_ocall(uint32_t session_id, 
		secure_message_t *resp_message,
		size_t resp_message_size,
		sgx_enclave_id_t wasm_vm_enclave_id)
{
	FIFO_MSG *msg_req = NULL, *msg_resp=NULL;
	FIFO_USER_REQ_MSG *msg_body;
	size_t req_size, resp_size;
	
	// wasm_vm_enclave_id is not used in this implementation, just for compatibility
	(void)wasm_vm_enclave_id;
	
	req_size = sizeof(FIFO_MSG_HEADER) + sizeof(FIFO_USER_REQ_MSG);

	msg_req = (FIFO_MSG *)malloc(req_size);
	if (!msg_req) return ERROR_OUT_OF_MEMORY;
	memset(msg_req, 0, req_size);

	msg_req->header.type = FIFO_USER_REQ;
	msg_req->header.size = sizeof(FIFO_USER_REQ_MSG);

	msg_body = (FIFO_USER_REQ_MSG*)msg_req->msgbuf;
	msg_body -> max_payload_size = 100; // later: check the max_payload_size of returned message;
	msg_body ->session_id = session_id;

	if (client_send_receive(msg_req, req_size, &msg_resp, &resp_size) != 0){
		free(msg_req);
		printf("fail to send and receive message.\n");
		return INVALID_SESSION;
	}

	memcpy(resp_message, msg_resp->msgbuf, msg_resp->header.size < resp_message_size ? msg_resp->header.size : resp_message_size);
	free(msg_req);
	free(msg_resp);
	return (ATTESTATION_STATUS)0;
}


/* Function Description: this is OCALL interface for initiator enclave to close secure session
 * Parameter Description:
 *      [input] session_id: this is session id allocated by responder enclave
 * */
ATTESTATION_STATUS end_session_ocall(uint32_t session_id, sgx_enclave_id_t wasm_vm_enclave_id)
{
	FIFO_MSG *msgresp = NULL;
	FIFO_MSG *closemsg;
	SESSION_CLOSE_REQ * body;
	size_t reqsize, respsize;
	
	// wasm_vm_enclave_id is not used in this implementation, just for compatibility
	(void)wasm_vm_enclave_id;

	reqsize = sizeof(FIFO_MSG) + sizeof(SESSION_CLOSE_REQ);
	closemsg = (FIFO_MSG *)malloc(reqsize);
	if (!closemsg)
	{
		return ERROR_OUT_OF_MEMORY;
	}
	memset(closemsg, 0,reqsize);

	closemsg->header.type = FIFO_DH_CLOSE_REQ;
	closemsg->header.size = sizeof(SESSION_CLOSE_REQ);

	body = (SESSION_CLOSE_REQ *)closemsg->msgbuf;
	body->session_id = session_id;

	if (client_send_receive(closemsg, reqsize, &msgresp, &respsize) != 0)
	{
		free(closemsg);
		printf("fail to send and receive message.\n");
		return INVALID_SESSION;
	}

	free(closemsg);
	free(msgresp);

	return (ATTESTATION_STATUS)0;
}


uint32_t create_file_header(uint32_t data_id, uint32_t budget, uint32_t file_size, uint32_t session_id, char **req_buf, uint32_t *req_size){
	// set fifo_msg;
	*req_size = sizeof(FIFO_MSG)+sizeof(USER_FILE_HEADER)+sizeof(SHIELD_REQ_MSG)+sizeof(enc_user_data);
	FIFO_MSG *req_msg = (FIFO_MSG*)malloc(sizeof(FIFO_MSG)+sizeof(USER_FILE_HEADER)+sizeof(SHIELD_REQ_MSG)+sizeof(enc_user_data));
	if (!req_msg) return MALLOC_ERROR;
	req_msg->header.type = FIFO_USER_FILE;
	req_msg->header.size = sizeof(USER_FILE_HEADER)+sizeof(SHIELD_REQ_MSG)+sizeof(enc_user_data);
	
	// set user file header;
	USER_FILE_HEADER *file_header = (USER_FILE_HEADER*)req_msg->msgbuf;
	file_header->file_size = file_size;
	file_header->data_id = data_id;

	SHIELD_REQ_MSG *shield_req = (SHIELD_REQ_MSG*) file_header->msgbuf;
	shield_req->session_id = session_id;
	shield_req->type = 0;
	shield_req->size = sizeof(enc_user_data);

	enc_user_data *user_data = (enc_user_data *)shield_req->buf;
	user_data->data_id = data_id;
	user_data->budget = budget;
	user_data->data_len = file_size;
	
	*req_buf = (char *)req_msg;

	return SUCCESS;
}


void ocall_printf(const char *str)
{
    printf("%s", str);
}

// Dummy implementations for DCAP functions - not used in this legacy implementation
ATTESTATION_STATUS ecdsa_quote_verification_ocall(uint8_t* quote_buffer, uint32_t quote_size)
{
#ifdef SGX_MODE_SIM
    return 0;
#else
    uint32_t ret = 0;
    time_t current_time = 0;
    uint32_t supplemental_data_size = 0;
    uint8_t *p_supplemental_data = NULL;
    sgx_ql_qv_result_t qv_result = SGX_QL_QV_RESULT_UNSPECIFIED;
    uint32_t collateral_expiration_status = 1;
    quote3_error_t dcap_ret = SGX_QL_SUCCESS;

    dcap_ret = sgx_qv_get_quote_supplemental_data_size(&supplemental_data_size);
    if (dcap_ret == SGX_QL_SUCCESS && supplemental_data_size > 0) {
        p_supplemental_data = (uint8_t*)malloc(supplemental_data_size);
    }

    time(&current_time);

    // sgx_ql_set_path(SGX_QL_QPL_PATH, "..."); 

    dcap_ret = sgx_qv_verify_quote(
        quote_buffer, 
        quote_size,
        NULL, // quote_collateral, NULL means use QPL to get collateral
        current_time,
        &collateral_expiration_status,
        &qv_result,
        NULL, // qv_report_info
        supplemental_data_size,
        p_supplemental_data
    );

    if (p_supplemental_data) free(p_supplemental_data);

    if (dcap_ret != SGX_QL_SUCCESS) {
        printf("Error in sgx_qv_verify_quote: 0x%04x\n", dcap_ret);
        return (ATTESTATION_STATUS)dcap_ret;
    }

    if (qv_result == SGX_QL_QV_RESULT_OK || 
        qv_result == SGX_QL_QV_RESULT_CONFIG_NEEDED || 
        qv_result == SGX_QL_QV_RESULT_OUT_OF_DATE || 
        qv_result == SGX_QL_QV_RESULT_OUT_OF_DATE_CONFIG_NEEDED || 
        qv_result == SGX_QL_QV_RESULT_SW_HARDENING_NEEDED || 
        qv_result == SGX_QL_QV_RESULT_CONFIG_AND_SW_HARDENING_NEEDED) {
        return (ATTESTATION_STATUS)0;
    } else {
        printf("Quote verification failed with result: 0x%04x\n", qv_result);
        return (ATTESTATION_STATUS)INVALID_SESSION;
    }
#endif
}

ATTESTATION_STATUS ecdsa_quote_generation_ocall(uint32_t* quote_size, sgx_report_t* app_report, uint8_t* quote)
{
#ifdef SGX_MODE_SIM
    if(quote_size) *quote_size = 0;
    return 0;
#else
    quote3_error_t qe3_ret = SGX_QL_SUCCESS;
    uint32_t real_quote_size = 0;

    qe3_ret = sgx_qe_get_quote_size(&real_quote_size);
    if (SGX_QL_SUCCESS != qe3_ret) {
        printf("Error in sgx_qe_get_quote_size. 0x%04x\n", qe3_ret);
        return (ATTESTATION_STATUS)qe3_ret;
    }

    *quote_size = real_quote_size;

    qe3_ret = sgx_qe_get_quote(app_report, real_quote_size, quote);
    if (SGX_QL_SUCCESS != qe3_ret) {
        printf("Error in sgx_qe_get_quote. 0x%04x\n", qe3_ret);
        return (ATTESTATION_STATUS)qe3_ret;
    }

    return (ATTESTATION_STATUS)0;
#endif
}

ATTESTATION_STATUS ecdsa_get_qe_target_info_ocall(sgx_target_info_t* qe_target_info)
{
#ifdef SGX_MODE_SIM
    memset(qe_target_info, 0, sizeof(sgx_target_info_t));
    return 0;
#else
    quote3_error_t qe3_ret = SGX_QL_SUCCESS;
    
    qe3_ret = sgx_qe_set_enclave_load_policy(SGX_QL_PERSISTENT);
    if(SGX_QL_SUCCESS != qe3_ret) {
        printf("Warning: set enclave load policy failed: 0x%04x\n", qe3_ret);
    }

    // Try to load PCE and QE3 from Ubuntu-like OS system path
    if (SGX_QL_SUCCESS != sgx_ql_set_path(SGX_QL_PCE_PATH, "/usr/lib/x86_64-linux-gnu/libsgx_pce.signed.so") ||
            SGX_QL_SUCCESS != sgx_ql_set_path(SGX_QL_QE3_PATH, "/usr/lib/x86_64-linux-gnu/libsgx_qe3.signed.so")) {
        // Try to load PCE and QE3 from RHEL-like OS system path
        if (SGX_QL_SUCCESS != sgx_ql_set_path(SGX_QL_PCE_PATH, "/usr/lib64/libsgx_pce.signed.so") ||
            SGX_QL_SUCCESS != sgx_ql_set_path(SGX_QL_QE3_PATH, "/usr/lib64/libsgx_qe3.signed.so")) {
            printf("Error in set PCE/QE3 directory.\n");
            return (ATTESTATION_STATUS)-1;
        }
    }
    // Set QPL path for quote provisioning
    qe3_ret = sgx_ql_set_path(SGX_QL_QPL_PATH, "/usr/lib/x86_64-linux-gnu/libdcap_quoteprov.so.1");
    if (SGX_QL_SUCCESS != qe3_ret) {
        qe3_ret = sgx_ql_set_path(SGX_QL_QPL_PATH, "/usr/lib64/libdcap_quoteprov.so.1");
        if(SGX_QL_SUCCESS != qe3_ret) {
            printf("Warning: Cannot set QPL directory, you may get ECDSA quote with `Encrypted PPID` cert type.\n");
        }
    }

    qe3_ret = sgx_qe_get_target_info(qe_target_info);
    if (SGX_QL_SUCCESS != qe3_ret) {
        printf("Error in sgx_qe_get_target_info. 0x%04x\n", qe3_ret);
        return (ATTESTATION_STATUS)qe3_ret;
    }
    return (ATTESTATION_STATUS)0;
#endif
}
