#include <map>
#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>

#include "sgx_eid.h"
#include "sgx_urts.h"
#include "sgx_dh.h"
#include "omp.h"

#include "fifo_def.h"
#include "error_codes.h"
#include "datatypes.h"
#include "UntrustedEnclaveMessageExchange.h"
#include "dcap_dh_def.h"
#include "sgx_dcap_ql_wrapper.h"
#include "sgx_quote_3.h"
#include "sgx_dcap_quoteverify.h"



/* Function Description: This is OCALL interface for initiator enclave to get ECDH message 1 and session id from responder enclave
 * Parameter Description:
 *      [input, output] dh_msg1: pointer to ecdh msg1 buffer, this buffer is allocated in initiator enclave and filled by responder enclave
 *      [output] session_id: pointer to session id which is allocated by responder enclave
 * */
extern "C" ATTESTATION_STATUS session_request_ocall(sgx_dh_dcap_msg1_t* dh_msg1, uint32_t* session_id){
	FIFO_MSG msg1_request;
	FIFO_MSG *msg1_response;
	SESSION_MSG1_RESP * msg1_respbody = NULL;
	size_t  msg1_resp_size;

	msg1_request.header.type = FIFO_DH_REQ_MSG1;
	msg1_request.header.size = 0;

	if ((client_send_receive(&msg1_request, sizeof(FIFO_MSG), &msg1_response, &msg1_resp_size) != 0)
		|| (msg1_response == NULL))
	{
		printf("fail to send and receive message.\n");
		return INVALID_SESSION;
	}

	msg1_respbody = (SESSION_MSG1_RESP *)msg1_response->msgbuf;
	memcpy(dh_msg1, &msg1_respbody->dh_msg1, sizeof(sgx_dh_dcap_msg1_t));
	*session_id = msg1_respbody->sessionid;
        free(msg1_response);

	return (ATTESTATION_STATUS)0;

}

/* Function Description: This is OCALL interface for initiator enclave to send ECDH message 2 to responder enclave, and receive ECDH message 3 from responder enclave
 * Parameter Description:
 *      [input] dh_msg2: this is pointer to ECDH message 2 generated by initiator enclave
 *      [input, output]dh_msg3: this is pointer to ECDH message 3, this buffer is allocated in initiator enclave and filled by responder enclave
 *      [input] session_id: this is session id allocated by responder enclave
 * */
ATTESTATION_STATUS exchange_report_ocall(sgx_dh_dcap_msg2_t *dh_msg2, sgx_dh_dcap_msg3_t *dh_msg3, uint32_t session_id)
{
	FIFO_MSG * msg2 = NULL, * msg3 = NULL;
	FIFO_MSG_HEADER * msg2_header = NULL;
	SESSION_MSG2 *msg2_body = NULL;
	SESSION_MSG3 *msg3_body = NULL;
	size_t msg2size, msg3size;

	msg2size = sizeof(FIFO_MSG_HEADER) + sizeof(SESSION_MSG2);
	msg2 = (FIFO_MSG *)malloc(msg2size);
	if (!msg2)
	{
		return ERROR_OUT_OF_MEMORY;
	}
	memset(msg2, 0, msg2size);

	msg2_header = (FIFO_MSG_HEADER *)msg2;
	msg2_header->type = FIFO_DH_MSG2;
	msg2_header->size = sizeof(SESSION_MSG2);

	msg2_body = (SESSION_MSG2 *)msg2->msgbuf;
	memcpy(&msg2_body->dh_msg2, dh_msg2, sizeof(sgx_dh_dcap_msg2_t));
	msg2_body->sessionid = session_id;

	if (client_send_receive(msg2, msg2size, &msg3, &msg3size) != 0)
	{
		free(msg2);
		printf("failed to send and receive message.\n");
		return INVALID_SESSION;
	}

	msg3_body = (SESSION_MSG3 *)msg3->msgbuf;
	memcpy(dh_msg3, &msg3_body->dh_msg3, sizeof(sgx_dh_dcap_msg3_t));

	free(msg3);
	free(msg2);

	return (ATTESTATION_STATUS)0;
}


/* Function Description: This is OCALL interface for initiator enclave to send request message(encrypted) to responder enclave, and receive response message from responder enclave
 * Parameter Description:
 *      [input] session_id: this is session id allocated by responder enclave
 *      [input] req_message: this is pointer to request message
 *      [input] req_message_size: this is request message size
 *      [input] max_payload_size: this is maximum payload size in response message
 *      [input, output] this is pointer to response message, the buffer is allocated by initiator enclave and filled by responder enclave
 *      [input] response message size
 * */
ATTESTATION_STATUS send_msg_ocall(uint32_t session_id, 
secure_message_t* req_message, 
size_t req_message_size, 
size_t max_payload_size, 
secure_message_t* resp_message, 
size_t resp_message_size)
{
	FIFO_MSG *msgreq = NULL, *msgresp= NULL;
	FIFO_MSGBODY_REQ * msgbody;

	size_t reqsize, respsize;

	reqsize = sizeof(FIFO_MSG_HEADER) + sizeof(FIFO_MSGBODY_REQ) + req_message_size;

	msgreq = (FIFO_MSG *)malloc(reqsize);
	if (!msgreq)
	{
		return ERROR_OUT_OF_MEMORY;
	}
	memset(msgreq, 0, reqsize);

	msgreq->header.type = FIFO_DH_MSG_REQ;
	msgreq->header.size = sizeof(FIFO_MSGBODY_REQ) + req_message_size;

	msgbody = (FIFO_MSGBODY_REQ *)msgreq->msgbuf;
	msgbody->max_payload_size = max_payload_size;
	msgbody->size = req_message_size;
	msgbody->session_id = session_id;

	memcpy(msgbody->buf, req_message, req_message_size);

	if (client_send_receive(msgreq, reqsize, &msgresp, &respsize) != 0)
	{
		free(msgreq);
		printf("fail to send and receive message.\n");
		return INVALID_SESSION;
	}

	memcpy(resp_message, msgresp->msgbuf, msgresp->header.size < resp_message_size ? msgresp->header.size : resp_message_size);
	free(msgresp);
	free(msgreq);

	return (ATTESTATION_STATUS)0;
}


/* Function Description: this is OCALL interface for initiator enclave to close secure session
 * Parameter Description:
 *      [input] session_id: this is session id allocated by responder enclave
 * */
ATTESTATION_STATUS end_session_ocall(uint32_t session_id)
{
	FIFO_MSG *msgresp = NULL;
	FIFO_MSG *closemsg;
	SESSION_CLOSE_REQ * body;
	size_t reqsize, respsize;

	reqsize = sizeof(FIFO_MSG) + sizeof(SESSION_CLOSE_REQ);
	closemsg = (FIFO_MSG *)malloc(reqsize);
	if (!closemsg)
	{
		return ERROR_OUT_OF_MEMORY;
	}
	memset(closemsg, 0,reqsize);

	closemsg->header.type = FIFO_DH_CLOSE_REQ;
	closemsg->header.size = sizeof(SESSION_CLOSE_REQ);

	body = (SESSION_CLOSE_REQ *)closemsg->msgbuf;
	body->session_id = session_id;

	if (client_send_receive(closemsg, reqsize, &msgresp, &respsize) != 0)
	{
		free(closemsg);
		printf("fail to send and receive message.\n");
		return INVALID_SESSION;
	}

	free(closemsg);
	free(msgresp);

	return (ATTESTATION_STATUS)0;
}

// Dummy implementations for DCAP functions
ATTESTATION_STATUS ecdsa_quote_verification_ocall(uint8_t* quote_buffer, uint32_t quote_size)
{
#ifdef SGX_MODE_SIM
    return (ATTESTATION_STATUS)0;
#else
    uint32_t ret = 0;
    time_t current_time = 0;
    uint32_t supplemental_data_size = 0;
    uint8_t *p_supplemental_data = NULL;
    sgx_ql_qv_result_t qv_result = SGX_QL_QV_RESULT_UNSPECIFIED;
    uint32_t collateral_expiration_status = 1;
    quote3_error_t dcap_ret = SGX_QL_SUCCESS;

    dcap_ret = sgx_qv_get_quote_supplemental_data_size(&supplemental_data_size);
    if (dcap_ret == SGX_QL_SUCCESS && supplemental_data_size > 0) {
        p_supplemental_data = (uint8_t*)malloc(supplemental_data_size);
    }

    time(&current_time);

    dcap_ret = sgx_qv_verify_quote(
        quote_buffer, 
        quote_size,
        NULL, // quote_collateral, NULL means use QPL to get collateral
        current_time,
        &collateral_expiration_status,
        &qv_result,
        NULL, // qv_report_info
        supplemental_data_size,
        p_supplemental_data
    );

    if (p_supplemental_data) free(p_supplemental_data);

    if (dcap_ret != SGX_QL_SUCCESS) {
        printf("Error in sgx_qv_verify_quote: 0x%04x\n", dcap_ret);
        return (ATTESTATION_STATUS)dcap_ret;
    }

    if (qv_result == SGX_QL_QV_RESULT_OK || 
        qv_result == SGX_QL_QV_RESULT_CONFIG_NEEDED || 
        qv_result == SGX_QL_QV_RESULT_OUT_OF_DATE || 
        qv_result == SGX_QL_QV_RESULT_OUT_OF_DATE_CONFIG_NEEDED || 
        qv_result == SGX_QL_QV_RESULT_SW_HARDENING_NEEDED || 
        qv_result == SGX_QL_QV_RESULT_CONFIG_AND_SW_HARDENING_NEEDED) {
        return (ATTESTATION_STATUS)0; // Verification passed
    } else {
        printf("Quote verification failed with result: 0x%04x\n", qv_result);
        return (ATTESTATION_STATUS)INVALID_SESSION;
    }
#endif
}

ATTESTATION_STATUS ecdsa_quote_generation_ocall(uint32_t* quote_size, sgx_report_t* app_report, uint8_t* quote)
{
#ifdef SGX_MODE_SIM
    if(quote_size) *quote_size = 0;
    return (ATTESTATION_STATUS)0;
#else
    quote3_error_t qe3_ret = SGX_QL_SUCCESS;
    uint32_t real_quote_size = 0;

    qe3_ret = sgx_qe_get_quote_size(&real_quote_size);
    if (SGX_QL_SUCCESS != qe3_ret) {
        printf("Error in sgx_qe_get_quote_size. 0x%04x\n", qe3_ret);
        return (ATTESTATION_STATUS)qe3_ret;
    }

    *quote_size = real_quote_size;

    qe3_ret = sgx_qe_get_quote(app_report, real_quote_size, quote);
    if (SGX_QL_SUCCESS != qe3_ret) {
        printf("Error in sgx_qe_get_quote. 0x%04x\n", qe3_ret);
        return (ATTESTATION_STATUS)qe3_ret;
    }

    return (ATTESTATION_STATUS)0;
#endif
}

ATTESTATION_STATUS ecdsa_get_qe_target_info_ocall(sgx_target_info_t* qe_target_info)
{
#ifdef SGX_MODE_SIM
    memset(qe_target_info, 0, sizeof(sgx_target_info_t));
    return (ATTESTATION_STATUS)0;
#else
    quote3_error_t qe3_ret = SGX_QL_SUCCESS;

    sgx_qe_set_enclave_load_policy(SGX_QL_PERSISTENT);

    qe3_ret = sgx_qe_get_target_info(qe_target_info);
    if (SGX_QL_SUCCESS != qe3_ret) {
        printf("Error in sgx_qe_get_target_info. 0x%04x\n", qe3_ret);
        return (ATTESTATION_STATUS)qe3_ret;
    }
    return (ATTESTATION_STATUS)0;
#endif
}

